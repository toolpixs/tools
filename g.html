<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Aqua Leap</title>
    <style>
        :root {
            --primary-color: #1a2a6c;
            --secondary-color: #b21f1f;
            --accent-color: #fdbb2d;
            --fish-color: #FFA500;
            --fish-fin-color: #FF8C00;
            --obstacle-color: #FF6347;
            --water-surface: #00BFFF;
            --water-mid: #1E90FF;
            --water-deep: #000080;
            --text-color: white;
            --text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background: linear-gradient(to bottom, var(--primary-color), var(--secondary-color), var(--accent-color));
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            color: var(--text-color);
            touch-action: manipulation;
        }

        .ad-container {
            width: 100%;
            min-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            overflow: hidden;
            transition: display 0.3s;
        }

        .ad-container.top-ad {
            height: 50px;
        }

        .ad-container.bottom-ad {
            height: 50px;
        }

        .ad-hidden {
            display: none;
        }

        .screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            text-align: center;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.5s ease-in;
            position: relative;
            overflow: hidden;
        }

        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
            z-index: -1;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .hidden {
            display: none !important;
        }

        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 8px;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            text-shadow: var(--text-shadow);
            position: relative;
            overflow: hidden;
            z-index: 1;
            min-width: 160px;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 50%);
            transform: translateX(-100%);
            transition: transform 0.5s;
            z-index: -1;
        }

        button:hover {
            background-color: #45a049;
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        button:hover::before {
            transform: translateX(100%);
        }

        button:active {
            transform: scale(0.98);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #game-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 100px);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas {
            background: linear-gradient(to bottom, var(--water-surface), var(--water-mid), var(--water-deep));
            border-radius: 0;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.7);
            max-width: 100%;
            max-height: 100%;
            display: block;
            touch-action: none;
        }

        #score-display {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px;
            color: var(--text-color);
            text-shadow: var(--text-shadow);
            background: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.7));
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            gap: 15px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
        }

        #score-display span {
            display: flex;
            align-items: center;
        }

        #score-display .score-value {
            font-weight: bold;
            margin-left: 5px;
            color: var(--accent-color);
        }

        #score-display.score-update {
            animation: scoreUpdate 0.3s ease;
        }

        @keyframes scoreUpdate {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); }
        }

        #tutorial-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            max-width: 90%;
            width: 350px;
            animation: fadeIn 0.5s ease-in;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }

        #tutorial-overlay h3 {
            margin-bottom: 15px;
            color: var(--accent-color);
            text-shadow: var(--text-shadow);
            font-size: 20px;
        }

        #tutorial-overlay p {
            margin-bottom: 10px;
            line-height: 1.5;
            font-size: 16px;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.7);
            z-index: 999;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            to { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
        }

        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            font-size: 36px;
            margin-bottom: 15px;
            text-shadow: var(--text-shadow);
        }

        h2 {
            font-size: 30px;
            margin-bottom: 15px;
            text-shadow: var(--text-shadow);
        }

        p {
            font-size: 16px;
            margin-bottom: 15px;
            text-shadow: var(--text-shadow);
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.4);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
        }

        @keyframes ripple {
            to { transform: scale(4); opacity: 0; }
        }

        @media (max-width: 480px) {
            h1 { font-size: 28px; }
            h2 { font-size: 24px; }
            p { font-size: 14px; }
            button { padding: 10px 20px; min-width: 140px; }
            #score-display { font-size: 14px; padding: 8px 16px; gap: 10px; }
            #tutorial-overlay { width: 90%; padding: 15px; }
            #tutorial-overlay h3 { font-size: 18px; }
            #tutorial-overlay p { font-size: 14px; }
            #countdown { font-size: 60px; }
        }

        @media (min-width: 768px) {
            h1 { font-size: 42px; }
            h2 { font-size: 36px; }
            #tutorial-overlay { width: 400px; }
        }
    </style>
</head>
<body>
    <div class="ad-container top-ad ad-hidden">
        <script type='text/javascript'>
            atOptions = {
                'key' : 'b1c589e314d0a9ee7da726ef34e47a4c',
                'format' : 'iframe',
                'height' : 50,
                'width' : 320,
                'params' : {}
            };
        </script>
        <script type='text/javascript' src='//increasingbelieveabonnement.com/b1c589e314d0a9ee7da726ef34e47a4c/invoke.js'></script>
    </div>

    <div id="welcome-screen" class="screen">
        <h1>Aqua Leap</h1>
        <p>Dive into adventure with your fish friend!</p>
        <p>Avoid obstacles and swim as far as you can</p>
        <button id="start-button">Start Game</button>
        <div id="high-score-display">
            <p>High Score: <span class="score-value" id="welcome-high-score">0</span></p>
        </div>
    </div>

    <div id="game-container" class="hidden">
        <canvas id="game-canvas"></canvas>
        <div id="score-display">
            <span>Score: <span class="score-value" id="score">0</span></span>
            <span>High: <span class="score-value" id="high-score">0</span></span>
        </div>
        <div id="tutorial-overlay" class="hidden">
            <h3>Welcome to Aqua Leap!</h3>
            <p>Tap, click, or press Space to make the fish swim up.</p>
            <p>Avoid the obstacles to score points!</p>
            <p>Click anywhere to start.</p>
        </div>
        <div id="countdown" class="hidden"></div>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h2>Game Over!</h2>
        <p>Your score: <span class="score-value" id="final-score">0</span></p>
        <p>High score: <span class="score-value" id="final-high-score">0</span></p>
        <button id="retry-button">Try Again</button>
        <button id="menu-button">Main Menu</button>
    </div>

    <div class="ad-container bottom-ad ad-hidden">
        <script type='text/javascript' src='//increasingbelieveabonnement.com/17/99/30/179930b4ed772b5dbadb1dcb9468b9a2.js'></script>
    </div>

    <audio id="background-music" preload="auto" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-game-show-suspense-waiting-668.mp3" type="audio/mpeg">
    </audio>
    <audio id="click-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-quick-jump-arcade-game-239.mp3" type="audio/mpeg">
    </audio>
    <audio id="game-over-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.mp3" type="audio/mpeg">
    </audio>
    <audio id="score-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3" type="audio/mpeg">
    </audio>
    <audio id="countdown-sound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-1699.mp3" type="audio/mpeg">
    </audio>
    <audio id="new-high-score" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" type="audio/mpeg">
    </audio>

    <script>
        const GRAVITY = 0.35;
        const JUMP_FORCE = -8;
        const INITIAL_OBSTACLE_SPEED = 3;
        const MIN_OBSTACLE_GAP = 250;
        const MAX_OBSTACLE_GAP = 350;
        const OBSTACLE_FREQUENCY = 1800;
        const SPEED_INCREMENT = 0.2;
        const POINTS_PER_INCREMENT = 5;
        const FISH_SWIM_SPEED = 2;
        const BUBBLE_COUNT = 5;
        const COUNTDOWN_TIME = 3;

        let canvas, ctx;
        let fish = {};
        let obstacles = [];
        let bubbles = [];
        let particles = [];
        let score = 0;
        let highScore = localStorage.getItem('aquaLeapHighScore') || 0;
        let gameRunning = false;
        let gameStarted = false;
        let lastObstacleTime = 0;
        let animationId;
        let countdownValue = COUNTDOWN_TIME;
        let countdownInterval;
        let currentObstacleSpeed = INITIAL_OBSTACLE_SPEED;
        let fishTargetY = 0;
        let fishInitialX = 0;
        let fishSwimProgress = 0;
        let obstacleWaveAmplitude = 0;
        let obstacleWaveFrequency = 0;
        let lastJumpTime = 0;
        let jumpCooldown = 100;

        let backgroundMusic, clickSound, gameOverSound, scoreSound, countdownSound, newHighScoreSound;
        let welcomeScreen, gameContainer, gameOverScreen, startButton, retryButton, menuButton;
        let scoreDisplay, highScoreDisplay, finalScoreDisplay, finalHighScoreDisplay, welcomeHighScoreDisplay;
        let tutorialOverlay, countdownDisplay;
        let topAdContainer, bottomAdContainer;

        function init() {
            welcomeScreen = document.getElementById('welcome-screen');
            gameContainer = document.getElementById('game-container');
            gameOverScreen = document.getElementById('game-over-screen');
            startButton = document.getElementById('start-button');
            retryButton = document.getElementById('retry-button');
            menuButton = document.getElementById('menu-button');
            scoreDisplay = document.getElementById('score');
            highScoreDisplay = document.getElementById('high-score');
            finalScoreDisplay = document.getElementById('final-score');
            finalHighScoreDisplay = document.getElementById('final-high-score');
            welcomeHighScoreDisplay = document.getElementById('welcome-high-score');
            tutorialOverlay = document.getElementById('tutorial-overlay');
            countdownDisplay = document.getElementById('countdown');
            topAdContainer = document.querySelector('.top-ad');
            bottomAdContainer = document.querySelector('.bottom-ad');

            backgroundMusic = document.getElementById('background-music');
            clickSound = document.getElementById('click-sound');
            gameOverSound = document.getElementById('game-over-sound');
            scoreSound = document.getElementById('score-sound');
            countdownSound = document.getElementById('countdown-sound');
            newHighScoreSound = document.getElementById('new-high-score');

            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            startButton.addEventListener('click', startGameFromMenu);
            retryButton.addEventListener('click', startGameFromOver);
            menuButton.addEventListener('click', returnToMenu);
            document.addEventListener('keydown', handleKeyPress);
            canvas.addEventListener('click', handleJump);
            canvas.addEventListener('touchstart', handleJump, { passive: false });
            tutorialOverlay.addEventListener('click', hideTutorial);

            highScoreDisplay.textContent = highScore;
            welcomeHighScoreDisplay.textContent = highScore;
            finalHighScoreDisplay.textContent = highScore;

            preloadAssets();
        }

        function preloadAssets() {
            backgroundMusic.volume = 0.3;
            clickSound.volume = 0.5;
            gameOverSound.volume = 0.5;
            scoreSound.volume = 0.3;
            countdownSound.volume = 0.5;
            newHighScoreSound.volume = 0.7;
        }

        function resizeCanvas() {
            const adHeight = 50; // Each ad is 50px high
            const totalAdHeight = 2 * adHeight; // Top and bottom ads
            const contentHeight = window.innerHeight - totalAdHeight;
            const contentWidth = window.innerWidth;

            canvas.width = contentWidth;
            canvas.height = contentHeight;

            if (fish.width) {
                fish.width = canvas.width / 10;
                fish.height = fish.width * 0.6;
                fish.x = fishInitialX;
                fish.y = canvas.height / 2;
            }
        }

        function showTutorial() {
            if (!localStorage.getItem('aquaLeapTutorialShown')) {
                tutorialOverlay.classList.remove('hidden');
                localStorage.setItem('aquaLeapTutorialShown', 'true');
            } else {
                startCountdown();
            }
        }

        function hideTutorial() {
            tutorialOverlay.classList.add('hidden');
            startCountdown();
        }

        function startCountdown() {
            countdownValue = COUNTDOWN_TIME;
            countdownDisplay.textContent = countdownValue;
            countdownDisplay.classList.remove('hidden');
            
            countdownInterval = setInterval(() => {
                countdownValue--;
                countdownDisplay.textContent = countdownValue;
                
                try {
                    countdownSound.currentTime = 0;
                    countdownSound.play().catch(e => console.log("Countdown sound error:", e));
                } catch (e) {
                    console.log("Countdown sound error:", e);
                }
                
                if (countdownValue <= 0) {
                    clearInterval(countdownInterval);
                    countdownDisplay.classList.add('hidden');
                    gameStarted = true;
                    lastObstacleTime = performance.now();
                }
            }, 1000);
        }

        function startGameFromMenu() {
            playClick();
            welcomeScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            topAdContainer.classList.add('ad-hidden');
            bottomAdContainer.classList.add('ad-hidden');
            setupGame();
        }

        function startGameFromOver() {
            playClick();
            gameOverScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            topAdContainer.classList.add('ad-hidden');
            bottomAdContainer.classList.add('ad-hidden');
            setupGame();
        }

        function returnToMenu() {
            playClick();
            gameOverScreen.classList.add('hidden');
            gameContainer.classList.add('hidden');
            welcomeScreen.classList.remove('hidden');
            welcomeHighScoreDisplay.textContent = highScore;
            topAdContainer.classList.add('ad-hidden');
            bottomAdContainer.classList.add('ad-hidden');
        }

        function setupGame() {
            fish = {
                x: -100,
                y: canvas.height / 2,
                width: canvas.width / 10,
                height: (canvas.width / 10) * 0.6,
                velocity: 0,
                targetRotation: 0,
                rotation: 0,
                tailAngle: 0,
                tailDirection: 1
            };
            
            fishInitialX = canvas.width / 4;
            fishTargetY = canvas.height / 2;
            fishSwimProgress = 0;

            obstacles = [];
            bubbles = [];
            particles = [];
            score = 0;
            scoreDisplay.textContent = score;
            gameRunning = true;
            gameStarted = false;
            currentObstacleSpeed = INITIAL_OBSTACLE_SPEED;
            obstacleWaveAmplitude = 0;
            obstacleWaveFrequency = 0;

            try {
                backgroundMusic.currentTime = 0;
                backgroundMusic.play().catch(e => console.log("Music play error:", e));
            } catch (e) {
                console.log("Music play error:", e);
            }

            showTutorial();
            gameLoop();
        }

        function gameOver() {
            gameRunning = false;
            gameStarted = false;
            cancelAnimationFrame(animationId);
            clearInterval(countdownInterval);
            
            try {
                backgroundMusic.pause();
                gameOverSound.currentTime = 0;
                gameOverSound.play().catch(e => console.log("Game over sound error:", e));
            } catch (e) {
                console.log("Audio error:", e);
            }
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('aquaLeapHighScore', highScore);
                try {
                    newHighScoreSound.currentTime = 0;
                    newHighScoreSound.play().catch(e => console.log("High score sound error:", e));
                } catch (e) {
                    console.log("High score sound error:", e);
                }
                createConfettiParticles();
            }
            
            highScoreDisplay.textContent = highScore;
            finalScoreDisplay.textContent = score;
            finalHighScoreDisplay.textContent = highScore;
            
            gameContainer.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            topAdContainer.classList.remove('ad-hidden');
            bottomAdContainer.classList.remove('ad-hidden');
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            
            updateFish();
            updateBubbles();
            updateParticles();
            
            if (gameStarted) {
                updateObstacles(timestamp);
            }
            
            drawBubbles();
            drawObstacles();
            drawFish();
            drawParticles();

            if (gameStarted && checkCollisions()) {
                gameOver();
                return;
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(0, 191, 255, 0.8)');
            gradient.addColorStop(0.4, 'rgba(30, 144, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 0, 128, 0.9)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            for (let i = 0; i < 5; i++) {
                const x = (Math.sin(Date.now() / 5000 + i) * canvas.width / 4) + canvas.width / 2;
                const width = 20 + Math.sin(Date.now() / 3000 + i) * 15;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + width, 0);
                ctx.lineTo(x + width / 2, canvas.height);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 20; i++) {
                const x = (Math.sin(Date.now() / 2000 + i * 100) * 50 + i * 150) % (canvas.width * 1.2);
                const y = (Date.now() / 10 + i * 80) % (canvas.height * 1.5);
                const size = 3 + Math.sin(Date.now() / 1000 + i) * 2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.fillStyle = '#e6c229';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            ctx.bezierCurveTo(
                canvas.width / 3, canvas.height - 30,
                canvas.width * 2/3, canvas.height - 40,
                canvas.width, canvas.height - 20
            );
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#d4b328';
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * canvas.width;
                const y = canvas.height - 20 + Math.random() * 20;
                const size = 1 + Math.random() * 3;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateFish() {
            if (!gameStarted) {
                if (fishSwimProgress < 1) {
                    fishSwimProgress += 0.01;
                    fish.x = easeOutQuad(fishSwimProgress, -100, fishInitialX, 1);
                    fish.y = canvas.height / 2;
                    fish.tailAngle = Math.sin(Date.now() / 100) * 0.5;
                } else {
                    fish.x = fishInitialX;
                    fish.y = canvas.height / 2;
                    fish.tailAngle = Math.sin(Date.now() / 100) * 0.5;
                }
                return;
            }
            
            fish.velocity += GRAVITY;
            fish.y += fish.velocity;
            
            const maxAngle = Math.PI / 4;
            fish.targetRotation = Math.max(-maxAngle, Math.min(maxAngle, fish.velocity * 0.1));
            fish.rotation += (fish.targetRotation - fish.rotation) * 0.1;
            
            fish.tailAngle += 0.2 * fish.tailDirection;
            if (Math.abs(fish.tailAngle) > 0.5) {
                fish.tailDirection *= -1;
            }
            
            if (fish.y < fish.height / 2) {
                fish.y = fish.height / 2;
                fish.velocity = 0;
            }
            if (fish.y > canvas.height - fish.height / 2) {
                fish.y = canvas.height - fish.height / 2;
                fish.velocity = 0;
            }
        }

        function easeOutQuad(t, b, c, d) {
            t /= d;
            return -c * t*(t-2) + b;
        }

        function drawFish() {
            ctx.save();
            ctx.translate(fish.x, fish.y);
            ctx.rotate(fish.rotation);
            
            ctx.fillStyle = 'rgba(255, 165, 0, 0.9)';
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.45, 0);
            ctx.bezierCurveTo(
                -fish.width * 0.3, -fish.height * 0.6,
                fish.width * 0.2, -fish.height * 0.8,
                fish.width * 0.45, 0
            );
            ctx.bezierCurveTo(
                fish.width * 0.2, fish.height * 0.8,
                -fish.width * 0.3, fish.height * 0.6,
                -fish.width * 0.45, 0
            );
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(255, 140, 0, 0.9)';
            ctx.beginPath();
            ctx.moveTo(-fish.width * 0.45, 0);
            ctx.quadraticCurveTo(
                -fish.width * 0.7, fish.height * fish.tailAngle,
                -fish.width * 0.45, fish.height * 0.5 * Math.sign(fish.tailAngle)
            );
            ctx.quadraticCurveTo(
                -fish.width * 0.4, 0,
                -fish.width * 0.45, -fish.height * 0.5 * Math.sign(fish.tailAngle)
            );
            ctx.quadraticCurveTo(
                -fish.width * 0.7, -fish.height * fish.tailAngle,
                -fish.width * 0.45, 0
            );
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(fish.width * 0.3, -fish.height * 0.2, fish.width * 0.05, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(fish.width * 0.3, -fish.height * 0.2, fish.width * 0.02, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 100, 0, 0.7)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                const x = fish.width * (0.1 - i * 0.05);
                ctx.beginPath();
                ctx.arc(x, 0, fish.height * 0.3, Math.PI * 0.8, Math.PI * 1.2);
                ctx.stroke();
            }
            
            const gradient = ctx.createRadialGradient(
                fish.width * 0.2, -fish.height * 0.2, 1,
                fish.width * 0.2, -fish.height * 0.2, fish.width * 0.2
            );
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(fish.width * 0.2, -fish.height * 0.2, fish.width * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function updateObstacles(timestamp) {
            if (timestamp - lastObstacleTime > OBSTACLE_FREQUENCY / (1 + score / 50)) {
                addObstacle();
                lastObstacleTime = timestamp;
            }
            
            const speedIncrease = Math.floor(score / POINTS_PER_INCREMENT) * SPEED_INCREMENT;
            currentObstacleSpeed = INITIAL_OBSTACLE_SPEED + speedIncrease;
            
            obstacleWaveAmplitude = score > 150 ? 30 + (score - 150) / 10 : 0;
            obstacleWaveFrequency = score > 150 ? 0.005 + (score - 150) / 10000 : 0;
            
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].x -= currentObstacleSpeed;
                
                if (obstacleWaveAmplitude > 0) {
                    obstacles[i].waveOffset = Math.sin(obstacles[i].initialX * obstacleWaveFrequency + timestamp * 0.002) * obstacleWaveAmplitude;
                } else {
                    obstacles[i].waveOffset = 0;
                }
                
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    continue;
                }
                
                if (!obstacles[i].passed && obstacles[i].x + obstacles[i].width < fish.x) {
                    obstacles[i].passed = true;
                    score++;
                    scoreDisplay.textContent = score;
                    scoreDisplay.classList.add('score-update');
                    setTimeout(() => scoreDisplay.classList.remove('score-update'), 300);
                    
                    if (score % 5 === 0) {
                        try {
                            scoreSound.currentTime = 0;
                            scoreSound.play().catch(e => console.log("Score sound error:", e));
                        } catch (e) {
                            console.log("Score sound error:", e);
                        }
                    }
                    
                    if (score > highScore) {
                        highScore = score;
                        highScoreDisplay.textContent = highScore;
                    }
                }
            }
        }

        function addObstacle() {
            const gapSize = Math.max(MIN_OBSTACLE_GAP, 
                                   Math.min(MAX_OBSTACLE_GAP, 
                                           MAX_OBSTACLE_GAP - score / 5));
            const minGapFromTop = 100;
            const minGapFromBottom = 100;
            const availableHeight = canvas.height - minGapFromTop - minGapFromBottom - gapSize;
            const gapPosition = minGapFromTop + Math.random() * availableHeight;
            const obstacleWidth = canvas.width / 8;
            const initialX = canvas.width;
            
            obstacles.push({
                x: initialX,
                y: 0,
                width: obstacleWidth,
                height: gapPosition,
                initialX: initialX,
                waveOffset: 0,
                color: '#FF6347',
                passed: false
            });
            
            obstacles.push({
                x: initialX,
                y: gapPosition + gapSize,
                width: obstacleWidth,
                height: canvas.height - (gapPosition + gapSize),
                initialX: initialX,
                waveOffset: 0,
                color: '#FF6347',
                passed: false
            });
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.save();
                if (obstacle.waveOffset !== 0) {
                    ctx.translate(0, obstacle.waveOffset);
                }
                
                ctx.fillStyle = obstacle.color;
                ctx.beginPath();
                if (obstacle.y === 0) {
                    ctx.moveTo(obstacle.x, obstacle.height);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.height);
                    const segments = 10;
                    const segmentWidth = obstacle.width / segments;
                    for (let i = 0; i <= segments; i++) {
                        const x = obstacle.x + i * segmentWidth;
                        const y = obstacle.height - 10 - Math.random() * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(obstacle.x, obstacle.height);
                } else {
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    const segments = 10;
                    const segmentWidth = obstacle.width / segments;
                    for (let i = 0; i <= segments; i++) {
                        const x = obstacle.x + i * segmentWidth;
                        const y = obstacle.y + 10 + Math.random() * 20;
                        ctx.lineTo(x, y);
                    }
                    ctx.lineTo(obstacle.x, obstacle.y);
                }
                ctx.closePath();
                ctx.fill();

                const detailCount = Math.floor(obstacle.width / 10);
                for (let i = 0; i < detailCount; i++) {
                    const x = obstacle.x + Math.random() * obstacle.width;
                    const y = obstacle.y === 0 ? 
                            Math.random() * obstacle.height * 0.8 : 
                            obstacle.y + Math.random() * obstacle.height * 0.2;
                    const size = 2 + Math.random() * 3;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }

        function updateBubbles() {
            bubbles.forEach(bubble => bubble.update());
            bubbles = bubbles.filter(bubble => bubble.y > -bubble.size);
            
            if (Math.random() < 0.02) {
                bubbles.push(new Bubble(
                    Math.random() * canvas.width,
                    canvas.height + 10,
                    true
                ));
            }
        }

        function drawBubbles() {
            bubbles.forEach(bubble => bubble.draw());
        }

        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.lifetime--;
                if (particle.lifetime <= 0) {
                    particles.splice(index, 1);
                } else {
                    particle.y += particle.vy;
                    particle.x += particle.vx;
                    particle.vy += particle.gravity;
                    particle.alpha = particle.lifetime / particle.maxLifetime;
                }
            });
        }

        function drawParticles() {
            particles.forEach(particle => {
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function checkCollisions() {
            if (fish.y - fish.height / 2 <= 0 || fish.y + fish.height / 2 >= canvas.height) {
                return true;
            }
            
            for (const obstacle of obstacles) {
                const obstacleY = obstacle.y + obstacle.waveOffset;
                if (
                    fish.x + fish.width / 2 > obstacle.x &&
                    fish.x - fish.width / 2 < obstacle.x + obstacle.width &&
                    fish.y + fish.height / 2 > obstacleY &&
                    fish.y - fish.height / 2 < obstacleY + obstacle.height
                ) {
                    return true;
                }
            }
            return false;
        }

        function handleJump(e) {
            const now = Date.now();
            if (now - lastJumpTime < jumpCooldown) return;
            lastJumpTime = now;
            
            if (!gameRunning || !gameStarted) {
                if (!gameRunning && tutorialOverlay.classList.contains('hidden')) {
                    startGameFromMenu();
                }
                return;
            }
            
            if (e.type === 'touchstart') {
                e.preventDefault();
            }
            
            fish.velocity = JUMP_FORCE;
            playClick();
            
            for (let i = 0; i < BUBBLE_COUNT; i++) {
                bubbles.push(new Bubble(
                    fish.x + (Math.random() - 0.5) * fish.width / 2,
                    fish.y + (Math.random() - 0.5) * fish.height / 2
                ));
            }
            
            createRipple(fish.x, fish.y);
        }

        function playClick() {
            try {
                clickSound.currentTime = 0;
                clickSound.play().catch(e => console.log("Click sound error:", e));
            } catch (e) {
                console.log("Click sound error:", e);
            }
        }

        function handleKeyPress(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                handleJump(e);
            }
        }

        class Bubble {
            constructor(x, y, isBackground = false) {
                this.x = x;
                this.y = y;
                this.size = isBackground ? Math.random() * 3 + 1 : Math.random() * 5 + 2;
                this.speed = isBackground ? Math.random() * 0.5 + 0.5 : Math.random() * 2 + 1;
                this.opacity = isBackground ? Math.random() * 0.3 + 0.1 : Math.random() * 0.5 + 0.3;
                this.wobble = Math.random() * 0.1;
                this.wobbleSpeed = Math.random() * 0.02 + 0.01;
                this.wobbleOffset = Math.random() * Math.PI * 2;
            }
            
            update() {
                this.y -= this.speed;
                this.x += Math.sin(Date.now() * this.wobbleSpeed + this.wobbleOffset) * this.wobble;
            }
            
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity + 0.2})`;
                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, this.y - this.size * 0.3, this.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function createRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'ripple';
            ripple.style.left = `${x}px`;
            ripple.style.top = `${y}px`;
            document.body.appendChild(ripple);
            
            setTimeout(() => {
                ripple.remove();
            }, 600);
        }

        function createConfettiParticles() {
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 5 + 2,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    lifetime: 100,
                    maxLifetime: 100,
                    gravity: 0.1,
                    alpha: 1
                });
            }
        }

        window.onload = init;
    </script>
</body>
</html>