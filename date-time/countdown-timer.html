<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Play Chess online for free at Toolpix Games! Enjoy single-player mode against a smart bot or challenge a friend in two-player mode. No downloads needed, playable on any device.">
  <title>Chess Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    body {
      background-color: #1c2526;
      color: #e0e0e0;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .welcome-screen {
      text-align: center;
      padding: 20px;
      background-color: #2d3839;
      margin: 20px;
      border-radius: 15px;
      animation: fadeIn 1s ease-in-out;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
      height: 100vh;
    }

    .welcome-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(212, 163, 115, 0.2) 0%, transparent 70%);
      opacity: 0.5;
      z-index: 0;
    }

    .welcome-screen h3, .welcome-screen .mode-selection, .welcome-screen .difficulty-selection {
      position: relative;
      z-index: 1;
    }

    .welcome-screen h3 {
      font-size: 28px;
      margin-bottom: 30px;
      animation: bounceIn 1s ease;
    }

    .mode-selection {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    .difficulty-selection {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      animation: fadeIn 0.5s ease-in-out;
    }

    .difficulty-selection select {
      background-color: #3a4b4c;
      color: #e0e0e0;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      font-size: 18px;
      cursor: pointer;
      transition: transform 0.3s ease, background-color 0.3s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      width: 200px;
      text-align: center;
    }

    .mode-button, .difficulty-button, .back-button {
      background-color: #3a4b4c;
      color: #e0e0e0;
      padding: 15px 30px;
      border: none;
      border-radius: 10px;
      font-size: 18px;
      cursor: pointer;
      transition: transform 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      min-width: 200px;
    }

    .mode-button:hover, .difficulty-button:hover, .back-button:hover {
      transform: scale(1.05);
      background-color: #d4a373;
      box-shadow: 0 6px 15px rgba(212, 163, 115, 0.6);
    }

    .game-section {
      display: none;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
      background-color: #1c2526;
      position: relative;
    }

    .game-section .back-button-container {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
    }

    .chessboard-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-grow: 1;
      padding: 10px;
      overflow: hidden;
      transition: transform 0.3s ease;
    }

    .chessboard-container:hover {
      transform: scale(1.02);
    }

    .chessboard {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0;
      margin: 0 auto;
      width: 100%;
      max-width: 100vmin;
      aspect-ratio: 1/1;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
      border: 5px solid #3a4b4c;
      background: url('https://www.transparenttextures.com/patterns/wood-pattern.png');
    }

    .cell {
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .cell.light {
      background-color: #f0d9b5;
    }

    .cell.dark {
      background-color: #b58863;
    }

    .cell:hover {
      transform: scale(1.05);
      box-shadow: 0 0 10px rgba(212, 163, 115, 0.5);
    }

    .cell img {
      width: 80%;
      height: 80%;
      object-fit: contain;
      transition: transform 0.3s ease;
    }

    .cell.selected {
      box-shadow: 0 0 15px #d4a373 inset;
      transform: scale(1.1);
    }

    .cell.possible-move::after {
      content: '';
      position: absolute;
      width: 25%;
      height: 25%;
      background-color: rgba(212, 163, 115, 0.5);
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }

    .game-info {
      font-size: 20px;
      font-weight: bold;
      margin: 10px 0;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .ad-banner {
      height: 60px;
      width: 100%;
      background-color: #2d3839;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 16px;
      color: #e0e0e0;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
    }

    .welcome-screen .ad-banner {
      margin-top: auto;
    }

    .popup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #2d3839;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.7);
      text-align: center;
      z-index: 2000;
      animation: popIn 0.4s ease;
      width: 90%;
      max-width: 400px;
    }

    .popup h3 {
      font-size: 24px;
      margin-bottom: 20px;
      color: #d4a373;
    }

    .popup-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .popup-button {
      background-color: #d4a373;
      color: #1c2526;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.3s ease, background-color 0.3s ease;
      min-width: 120px;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes bounceIn {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-30px); }
      60% { transform: translateY(-15px); }
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      80% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    @media (max-width: 768px) {
      .welcome-screen {
        margin: 10px;
        padding: 15px;
      }

      .mode-selection {
        flex-direction: column;
        gap: 10px;
      }

      .mode-button, .difficulty-button {
        padding: 12px 20px;
        font-size: 16px;
        min-width: 160px;
      }

      .game-info {
        font-size: 16px;
      }

      .chessboard {
        border-width: 3px;
      }
    }
  </style>
</head>
<body>
  <div class="welcome-screen" id="welcomeScreen">
    <h3 id="welcomeTitle">Choose Your Game Mode</h3>
    <div class="mode-selection" id="modeSelection">
      <button class="mode-button" onclick="showDifficultySelection()" aria-label="Start single-player game against bot">Single Player (vs Bot)</button>
      <button class="mode-button" onclick="startGame('multi', 'none')" aria-label="Start two-player game">Two Players</button>
    </div>
    <div class="difficulty-selection" id="difficultySelection">
      <select id="difficultyLevel" aria-label="Select difficulty level">
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard" selected>Hard</option>
      </select>
      <div class="difficulty-buttons">
        <button class="difficulty-button" onclick="startGame('single', document.getElementById('difficultyLevel').value)" aria-label="Start single-player game">Start Game</button>
        <button class="difficulty-button" onclick="backToModeSelection()" aria-label="Back to mode selection">Back</button>
      </div>
    </div>
    <div class="ad-banner">Advertisement</div>
  </div>

  <div class="game-section" id="gameSection">
    <div class="back-button-container">
      <button class="back-button" onclick="backToWelcome()" aria-label="Return to welcome screen">Back</button>
    </div>
    <div class="chessboard-container">
      <div class="chessboard" id="chessboard"></div>
    </div>
    <div class="game-info" id="gameInfo">White's turn</div>
    <div class="ad-banner">Advertisement</div>
  </div>

  <div class="popup" id="gamePopup">
    <h3 id="popupMessage"></h3>
    <div class="popup-buttons">
      <button class="popup-button" onclick="restartGame()" aria-label="Restart the game">Restart Game</button>
      <button class="popup-button" onclick="backToWelcome()" aria-label="Return to welcome screen">Back</button>
    </div>
  </div>

  <script>
    // Game state and configuration
    const initialBoard = [
      ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
      ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
      ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
    ];

    const pieceImages = {
      'wp': 'https://i.ibb.co/6y3sxJ1/Wpawn.png',
      'wn': 'https://i.ibb.co/6Zz1Yy2/Wknight.png',
      'wb': 'https://i.ibb.co/k6Yb0XG/Wbishop.png',
      'wr': 'https://i.ibb.co/8K7g8gQ/Wrook.png',
      'wq': 'https://i.ibb.co/9wL2D0Q/Wqueen.png',
      'wk': 'https://i.ibb.co/7tXbL7B/Wking.png',
      'bp': 'https://i.ibb.co/5sXJ3gJ/Bpawn.png',
      'bn': 'https://i.ibb.co/8N2L5gQ/Bknight.png',
      'bb': 'https://i.ibb.co/4sB0ZgQ/Bbishop.png',
      'br': 'https://i.ibb.co/3FzL7gQ/Brook.png',
      'bq': 'https://i.ibb.co/6N2L5gQ/Bqueen.png',
      'bk': 'https://i.ibb.co/5sXJ3gQ/Bking.png'
    };

    // Game state variables
    let board = [];
    let currentPlayer = 'w';
    let gameActive = false;
    let gameMode = '';
    let difficulty = 'hard';
    let selectedPiece = null;
    let possibleMoves = [];

    // Initialize the game
    function initGame() {
      const savedGame = localStorage.getItem('chessGame');
      if (savedGame) {
        const gameState = JSON.parse(savedGame);
        board = gameState.board;
        currentPlayer = gameState.currentPlayer;
        gameMode = gameState.gameMode;
        difficulty = gameState.difficulty || 'hard';
        gameActive = true;
        
        document.getElementById('welcomeScreen').style.display = 'none';
        document.getElementById('gameSection').style.display = 'flex';
        document.getElementById('gameInfo').textContent = `${currentPlayer === 'w' ? 'White' : 'Black'}'s turn`;
        initChessboard();
        renderBoard();
        
        if (gameMode === 'single' && currentPlayer === 'b') {
          setTimeout(botMove, 500);
        }
      }
    }

    // Initialize chessboard UI
    function initChessboard() {
      const chessboard = document.getElementById('chessboard');
      chessboard.innerHTML = '';
      chessboard.style.gridTemplateColumns = `repeat(8, 1fr)`;
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
          chessboard.appendChild(cell);
        }
      }
      chessboard.addEventListener('click', handleCellClick);
    }

    // UI Navigation Functions
    function showDifficultySelection() {
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'flex';
      document.getElementById('welcomeTitle').textContent = 'Select Difficulty';
    }

    function backToModeSelection() {
      document.getElementById('modeSelection').style.display = 'flex';
      document.getElementById('difficultySelection').style.display = 'none';
      document.getElementById('welcomeTitle').textContent = 'Choose Your Game Mode';
    }

    function startGame(mode, diff) {
      gameMode = mode;
      difficulty = diff || 'none';
      gameActive = true;
      board = initialBoard.map(row => row.slice());
      currentPlayer = 'w';
      selectedPiece = null;
      possibleMoves = [];
      
      saveGameState();
      
      document.getElementById('welcomeScreen').style.display = 'none';
      document.getElementById('gameSection').style.display = 'flex';
      document.getElementById('gameInfo').textContent = "White's turn";
      document.getElementById('gamePopup').style.display = 'none';
      initChessboard();
      renderBoard();
    }

    function backToWelcome() {
      gameActive = false;
      localStorage.removeItem('chessGame');
      document.getElementById('gameSection').style.display = 'none';
      document.getElementById('welcomeScreen').style.display = 'flex';
      document.getElementById('gamePopup').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'flex';
      document.getElementById('difficultySelection').style.display = 'none';
      document.getElementById('welcomeTitle').textContent = 'Choose Your Game Mode';
    }

    // Save game state to localStorage
    function saveGameState() {
      const gameState = {
        board: board,
        currentPlayer: currentPlayer,
        gameMode: gameMode,
        difficulty: difficulty
      };
      localStorage.setItem('chessGame', JSON.stringify(gameState));
    }

    // Render the board
    function renderBoard() {
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        const piece = board[row][col];
        cell.innerHTML = '';
        cell.classList.remove('selected', 'possible-move');
        
        if (piece) {
          const img = document.createElement('img');
          img.src = pieceImages[piece];
          img.alt = piece;
          cell.appendChild(img);
        }
        
        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
          cell.classList.add('selected');
        }
        
        if (possibleMoves.some(m => m.row === row && m.col === col)) {
          cell.classList.add('possible-move');
        }
      });
    }

    // Handle cell clicks
    function handleCellClick(event) {
      if (!gameActive) return;
      
      const cell = event.target.closest('.cell');
      if (!cell) return;
      
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);

      if (selectedPiece) {
        const move = possibleMoves.find(m => m.row === row && m.col === col);
        if (move) {
          makeMove(selectedPiece.row, selectedPiece.col, row, col);
        }
        selectedPiece = null;
        possibleMoves = [];
        renderBoard();
      } else {
        const piece = board[row][col];
        if (piece && piece[0] === currentPlayer) {
          selectedPiece = { row, col };
          possibleMoves = getLegalMoves(row, col);
          renderBoard();
        }
      }
    }

    // Chess move logic
    function makeMove(fromRow, fromCol, toRow, toCol) {
      const piece = board[fromRow][fromCol];
      
      board[toRow][toCol] = piece;
      board[fromRow][fromCol] = '';
      
      currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
      document.getElementById('gameInfo').textContent = `${currentPlayer === 'w' ? 'White' : 'Black'}'s turn`;
      
      saveGameState();
      
      if (isCheckmate(currentPlayer)) {
        showPopup(`${currentPlayer === 'w' ? 'Black' : 'White'} wins by checkmate!`);
        gameActive = false;
        localStorage.removeItem('chessGame');
      } else if (isStalemate(currentPlayer)) {
        showPopup("Stalemate! It's a draw.");
        gameActive = false;
        localStorage.removeItem('chessGame');
      } else if (gameMode === 'single' && currentPlayer === 'b') {
        setTimeout(botMove, 500);
      }
    }

    // Bot move logic
    function botMove() {
      if (!gameActive || currentPlayer !== 'b') return;
      
      const allMoves = getAllLegalMoves('b');
      if (allMoves.length === 0) {
        if (isInCheck('b')) {
          showPopup('White wins by checkmate!');
        } else {
          showPopup("Stalemate! It's a draw.");
        }
        gameActive = false;
        localStorage.removeItem('chessGame');
        return;
      }
      
      let move;
      if (difficulty === 'easy') {
        move = allMoves[Math.floor(Math.random() * allMoves.length)];
      } else if (difficulty === 'medium') {
        const captureMoves = allMoves.filter(m => board[m.toRow][m.toCol] !== '');
        move = captureMoves.length > 0 ? 
          captureMoves[Math.floor(Math.random() * captureMoves.length)] : 
          allMoves[Math.floor(Math.random() * allMoves.length)];
      } else if (difficulty === 'hard') {
        let bestScore = -Infinity;
        for (const m of allMoves) {
          const originalPiece = board[m.toRow][m.toCol];
          board[m.toRow][m.toCol] = board[m.fromRow][m.fromCol];
          board[m.fromRow][m.fromCol] = '';
          const score = minimax(2, false);
          board[m.fromRow][m.fromCol] = board[m.toRow][m.toCol];
          board[m.toRow][m.toCol] = originalPiece;
          if (score > bestScore) {
            bestScore = score;
            move = m;
          }
        }
      }
      
      makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
      renderBoard();
    }

    // Chess rules implementation
    function getPseudoLegalMoves(row, col) {
      const piece = board[row][col];
      if (!piece) return [];
      
      const color = piece[0];
      const type = piece[1];
      
      if (type === 'p') return getPawnMoves(row, col, color);
      if (type === 'n') return getKnightMoves(row, col, color);
      if (type === 'b') return getBishopMoves(row, col, color);
      if (type === 'r') return getRookMoves(row, col, color);
      if (type === 'q') return getQueenMoves(row, col, color);
      if (type === 'k') return getKingMoves(row, col, color);
      return [];
    }

    function getLegalMoves(row, col) {
      const piece = board[row][col];
      if (!piece || piece[0] !== currentPlayer) return [];
      
      const pseudoMoves = getPseudoLegalMoves(row, col);
      const legalMoves = [];
      
      for (const move of pseudoMoves) {
        const originalPiece = board[move.row][move.col];
        board[move.row][move.col] = piece;
        board[row][col] = '';
        
        if (!isInCheck(currentPlayer)) {
          legalMoves.push(move);
        }
        
        board[row][col] = piece;
        board[move.row][move.col] = originalPiece;
      }
      
      return legalMoves;
    }

    function getPawnMoves(row, col, color) {
      const moves = [];
      const dir = color === 'w' ? -1 : 1;
      const startRow = color === 'w' ? 6 : 1;
      
      const newRow = row + dir;
      if (newRow >= 0 && newRow < 8 && !board[newRow][col]) {
        moves.push({ row: newRow, col });
        if (row === startRow && !board[row + 2 * dir][col]) {
          moves.push({ row: row + 2 * dir, col });
        }
      }
      
      const captures = [[newRow, col - 1], [newRow, col + 1]];
      for (const [r, c] of captures) {
        if (r >= 0 && r < 8 && c >= 0 && c < 8 && board[r][c] && board[r][c][0] !== color) {
          moves.push({ row: r, col: c });
        }
      }
      
      return moves;
    }

    function getKnightMoves(row, col, color) {
      const moves = [];
      const deltas = [
        [-2, -1], [-2, 1], [2, -1], [2, 1],
        [-1, -2], [-1, 2], [1, -2], [1, 2]
      ];
      
      for (const [dr, dc] of deltas) {
        const r = row + dr;
        const c = col + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
          const target = board[r][c];
          if (!target || target[0] !== color) {
            moves.push({ row: r, col: c });
          }
        }
      }
      
      return moves;
    }

    function getBishopMoves(row, col, color) {
      const moves = [];
      const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
      
      for (const [dr, dc] of directions) {
        let r = row + dr;
        let c = col + dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          const target = board[r][c];
          if (!target) {
            moves.push({ row: r, col: c });
          } else {
            if (target[0] !== color) moves.push({ row: r, col: c });
            break;
          }
          r += dr;
          c += dc;
        }
      }
      
      return moves;
    }

    function getRookMoves(row, col, color) {
      const moves = [];
      const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      
      for (const [dr, dc] of directions) {
        let r = row + dr;
        let c = col + dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          const target = board[r][c];
          if (!target) {
            moves.push({ row: r, col: c });
          } else {
            if (target[0] !== color) moves.push({ row: r, col: c });
            break;
          }
          r += dr;
          c += dc;
        }
      }
      
      return moves;
    }

    function getQueenMoves(row, col, color) {
      return [...getRookMoves(row, col, color), ...getBishopMoves(row, col, color)];
    }

    function getKingMoves(row, col, color) {
      const moves = [];
      const deltas = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1],           [0, 1],
        [1, -1],  [1, 0],  [1, 1]
      ];
      
      for (const [dr, dc] of deltas) {
        const r = row + dr;
        const c = col + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
          const target = board[r][c];
          if (!target || target[0] !== color) {
            moves.push({ row: r, col: c });
          }
        }
      }
      
      return moves;
    }

    function findKing(player) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (board[r][c] === player + 'k') return { row: r, col: c };
        }
      }
      return null;
    }

    function isInCheck(player) {
      const kingPos = findKing(player);
      if (!kingPos) return false;
      
      const opponent = player === 'w' ? 'b' : 'w';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && piece[0] === opponent) {
            const moves = getPseudoLegalMoves(r, c);
            if (moves.some(m => m.row === kingPos.row && m.col === kingPos.col)) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function getAllLegalMoves(player) {
      const moves = [];
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece && piece[0] === player) {
            const pieceMoves = getLegalMoves(r, c);
            pieceMoves.forEach(m => moves.push({ 
              fromRow: r, 
              fromCol: c, 
              toRow: m.row, 
              toCol: m.col 
            }));
          }
        }
      }
      return moves;
    }

    function isCheckmate(player) {
      return isInCheck(player) && getAllLegalMoves(player).length === 0;
    }

    function isStalemate(player) {
      return !isInCheck(player) && getAllLegalMoves(player).length === 0;
    }

    function minimax(depth, isMaximizing) {
      if (depth === 0 || isCheckmate('w') || isCheckmate('b') || isStalemate('w') || isStalemate('b')) {
        return evaluateBoard();
      }
      
      if (isMaximizing) {
        let bestScore = -Infinity;
        const moves = getAllLegalMoves('b');
        for (const m of moves) {
          const originalPiece = board[m.toRow][m.toCol];
          board[m.toRow][m.toCol] = board[m.fromRow][m.fromCol];
          board[m.fromRow][m.fromCol] = '';
          const score = minimax(depth - 1, false);
          board[m.fromRow][m.fromCol] = board[m.toRow][m.toCol];
          board[m.toRow][m.toCol] = originalPiece;
          bestScore = Math.max(score, bestScore);
        }
        return bestScore;
      } else {
        let bestScore = Infinity;
        const moves = getAllLegalMoves('w');
        for (const m of moves) {
          const originalPiece = board[m.toRow][m.toCol];
          board[m.toRow][m.toCol] = board[m.fromRow][m.fromCol];
          board[m.fromRow][m.fromCol] = '';
          const score = minimax(depth - 1, true);
          board[m.fromRow][m.fromCol] = board[m.toRow][m.toCol];
          board[m.toRow][m.toCol] = originalPiece;
          bestScore = Math.min(score, bestScore);
        }
        return bestScore;
      }
    }

    function evaluateBoard() {
      const pieceValues = { 'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9, 'k': 100 };
      let score = 0;
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = board[r][c];
          if (piece) {
            const value = pieceValues[piece[1]] || 0;
            score += piece[0] === 'w' ? value : -value;
          }
        }
      }
      return score;
    }

    // UI Helpers
    function showPopup(message) {
      document.getElementById('popupMessage').textContent = message;
      document.getElementById('gamePopup').style.display = 'block';
    }

    function restartGame() {
      startGame(gameMode, difficulty);
    }

    // Initialize the game when page loads
    window.addEventListener('DOMContentLoaded', initGame);
  </script>
</body>
</html>